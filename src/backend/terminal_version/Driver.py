import Questionnaire
import PlaylistRec
import ArtistRec
import AccountRec

import os
import sys

# getting the name of the directory
# where the this file is present.
current = os.path.dirname(os.path.realpath(__file__))

# Getting the parent directory name
# where the current directory is present.
parent = os.path.dirname(current)

# adding the parent directory to 
# the sys.path.
sys.path.append(parent)

#Must add backend folder to the syspath to allow the driver file to import from the backend parent folder
import GeminiConnect
import SpotifyConnect

#Main method to determine whether a user is going to use a Spotify account or not
def main():
    user_input = int(input("Please enter a number: 1. No Spotify Account, 2. Spotify Account \n"))

    #No Spotify Case
    if user_input==1:
        no_spotify()
    elif user_input==2:
        has_spotify_account()

#A function that considers the case where one lacks or doesn't want to use a Spotify account
#"Offline" users will only be able to generate a questionnaire prompt
def no_spotify():
    prompt=Questionnaire.questionnaire()
    
    response=use_gemini(prompt)
    print(response)
 
#A function that considers the case of a user having a Spotify account. 
#Used to first select which generation class to will be used,
#then prompt Gemini API for a playlist, then prompt Spotify API to generate the playlist
#to the user's account.
def has_spotify_account():
    #Initialize SpotifyConnect object
    my_spotify = SpotifyConnect.SpotifyConnect()

    user_input = int(input("Please enter a number: 1. Questionnaire, 2. Playlist , 4. Artist, 5.Logout \n"))
    
    prompt=""
    
    #Questionnaire case
    if user_input==1:
        prompt=Questionnaire.questionnaire()
    #Playlist case
    elif user_input==2:
        playlist_tracks=my_spotify.get_user_playlist()

        prompt=PlaylistRec.playlist_rec(playlist_tracks)
    #Artist case
    elif user_input==3:
        prompt=ArtistRec.artist_rec()
    #Account case
    elif user_input==4:
        top_artists=my_spotify.get_user_top_artists()
        
        prompt=AccountRec.account_rec(top_artists)
    #Logout case
    elif user_input==5:
        logout_user()
        
    if user_input!=5:
        #Use the Gemini and Spotify APIs. This is the last step.    
        use_APIs(prompt,my_spotify)    
    
#@param String:prompt
#@return String: GeminiConnect.generate_playlist
#Used to fetch the playlist generated by Gemini API 
def use_gemini(prompt):
    return GeminiConnect.generate_playlist(prompt)

#@param String: song_list
#Used to parse through the Gemini generated string of songs to create an array of songs
#specifying title, artist, and year. Afterwards, use Spotify API to search for the songs
#and generate a playlist on the account.
#Now checks for correct formatting of the song_list.
def use_spotify(song_list,my_spotify):
    songs=[]
    correct_format=False
    try:
        for line in song_list.strip().split('\n'):
            title, rest = line.split(' /// ')
            album, rest = rest.split(' ### ')
            artist, year = rest.split(' (')
            year = year.rstrip(')')
            songs.append({'artist': artist, "title": title, "album":album, "year": year})
        
        my_spotify.search_songs(songs)
        #Formatting is correct, no need to retry the process
        correct_format=True
        return correct_format
    except:
        #Formatting is incorrect, retry the process
        print("Incorrect format")
        
        return correct_format


#Function that uses both APIs, and loops until a valid gemini response is created for use_spotify.
#Implemented primarily to avoid multiple instances of the same code across the prompt-making functions.
def use_APIs(prompt,spotify_instance):
    spotifyCheck=False
    
    while spotifyCheck==False:
        response = use_gemini(prompt)
        print(response)
        
        spotifyCheck=use_spotify(response,spotify_instance)
    
   
#Allows the user to perform a "logout" by just deleting the .cache file, and restarting the program    
def logout_user():
    dir_path=os.getcwd()
    cache_path=dir_path+"/src/backend/.cache"
    #delete .cache file
    os.remove(cache_path)
    
    #restart the program
    main()
    
    
    
if __name__ == "__main__":
    main()
